<!DOCTYPE html>
<html>
<head><style>
#controls {
  width:25%; float:right;
}
#glcanvas {
  border:1px solid #000000;
  float:left; width:50%;
}
#controls {
    font-family: Arial, sans-serif;
    background-color: #f0f0f0;
    border-left: 2px solid #ddd;
    box-sizing: border-box;
    height: 100vh;
    overflow-y: auto;
    padding-left:1em;
}

#controls h2 {
    color: #333;
}

#controls div {
    margin-bottom: 10px;
}

label {
    display: block;
    margin-bottom: 5px;
    color: #666;
}

input, button {
    width: 100%;
    padding: 8px;
    margin-top: 5px;
    box-sizing: border-box;
}

button {
    background-color: #5C8FCE;
    color: white;
    border: none;
    cursor: pointer;
}

button:hover {
    background-color: #4B7CB0;
}

</style></head>
<body>

<div id="controls">
    <h2>L-System Controls</h2>
    <div>
        <label for="axiom">Axiom:</label>
        <input type="text" id="axiom" value="F">
    </div>
    <div>
        <label for="rule">Rule (F=):</label>
        <input type="text" id="rule" value="FF+[+F-F-F]-[-F+F+F]">
    </div>
    <div>
        <label for="depth">Recursion Depth:</label>
        <input type="number" id="depth" value="5">
    </div>
    <div>
        <label for="angle">Angle:</label>
        <input type="number" id="angle" value="25">
    </div>
    <button id="update">Update L-System</button>
</div>

<canvas id="glcanvas" width="800" height="600"></canvas>
<script>

// Vertex shader program and WebGL initialization code
const vsSource = `
attribute vec4 aVertexPosition;
attribute float aDistance;
varying highp float vDistance;

void main(void) {
    gl_Position = aVertexPosition;
    vDistance = aDistance;
}
`;

// Fragment shader program
const fsSource = `
precision mediump float;
varying highp float vDistance;

void main(void) {
    float modDistance = mod(vDistance, 1.0);
    vec3 colorA = vec3(0.1, 0.2, 0.5); // Darker blue
    vec3 colorB = vec3(0.4, 0.1, 0.2); // Darker pink
    vec3 colorC = vec3(0.1, 0.5, 0.1); // Darker green

    vec3 color;
    if(modDistance < 0.33) {
        color = mix(colorA, colorB, modDistance / 0.33);
    } else if(modDistance < 0.66) {
        color = mix(colorB, colorC, (modDistance - 0.33) / 0.33);
    } else {
        color = mix(colorC, colorA, (modDistance - 0.66) / 0.33);
    }

    gl_FragColor = vec4(color, 1.); // Apply color with translucency
}

`;
function initShaderProgram(gl, vsSource, fsSource) {
    const vertexShader = loadShader(gl, gl.VERTEX_SHADER, vsSource);
    const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fsSource);

    // Create the shader program
    const shaderProgram = gl.createProgram();
    gl.attachShader(shaderProgram, vertexShader);
    gl.attachShader(shaderProgram, fragmentShader);
    gl.linkProgram(shaderProgram);

    // Check if the shader program was successfully linked
    if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
        alert('Unable to initialize the shader program: ' + gl.getProgramInfoLog(shaderProgram));
        return null;
    }

    return shaderProgram;
}

function loadShader(gl, type, source) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);

    // Check if the shader was successfully compiled
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        alert('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(shader));
        gl.deleteShader(shader);
        return null;
    }

    return shader;
}

function initWebGL(canvas) {
    const gl = canvas.getContext("webgl");
    if (!gl) {
        alert("Unable to initialize WebGL. Your browser may not support it.");
        return null;
    }

    const shaderProgram = initShaderProgram(gl, vsSource, fsSource); // Assume this function is correctly implemented
    gl.useProgram(shaderProgram);

    // Adjust canvas size to match display size
    canvas.width = canvas.clientWidth;
    canvas.height = canvas.clientHeight;
    gl.viewport(0, 0, canvas.width, canvas.height);

    // Clear the canvas
    gl.clearColor(0.0, 0.0, 0.0, 1.0); // Clear to black, fully opaque
    gl.clear(gl.COLOR_BUFFER_BIT);

    return {gl, shaderProgram};
}

/* Utility Functions */
function calculateBounds(instructions, angle) {
    let x = 0, y = 0, dir = Math.PI / 2; // Starting conditions
    const rad = (a) => a * (Math.PI / 180);
    const stack = [];
    let minX = 0, maxX = 0, minY = 0, maxY = 0;

    instructions.split('').forEach((cmd) => {
        switch(cmd) {
            case 'F':
                x += Math.cos(dir);
                y += Math.sin(dir);
                minX = Math.min(minX, x);
                maxX = Math.max(maxX, x);
                minY = Math.min(minY, y);
                maxY = Math.max(maxY, y);
                break;
            case '+':
                dir += rad(angle);
                break;
            case '-':
                dir -= rad(angle);
                break;
            case '[':
                stack.push({x, y, dir});
                break;
            case ']':
                const state = stack.pop();
                x = state.x;
                y = state.y;
                dir = state.dir;
                break;
        }
    });

    return {minX, maxX, minY, maxY};
}


/* Core Functions */
function drawLSystem(gl, shaderProgram, instructions, angle) {
    let dir = Math.PI / 2; // Start direction (upwards)
    const rad = (a) => a * (Math.PI / 180);
    const stack = [];
    let vertices = [];
    let distance = 0; // Initialize distance
    let distanceAttributes = []; // Array for distance attributes

    // Parameters for line rendering
    let thicknessBase = 0.0007; // Base thickness of lines
    let stepSize = 0.02; // Step size for 'F' movement

    // Starting position in normalized device coordinates (NDC)
    let x = 0, y = -0.5; // Starting near the bottom-center of the screen

    instructions.split('').forEach(cmd => {
        switch (cmd) {
            case 'F':
                // Calculate next point
                let newX = x + Math.cos(dir) * stepSize;
                let newY = y + Math.sin(dir) * stepSize;

                // Increase thickness based on distance
                let thickness = thicknessBase + distance * 0.0003; // Adjust factor to scale thickness change

                // Calculate perpendicular vector for thickness
                let perpX = Math.cos(dir + Math.PI / 2) * thickness;
                let perpY = Math.sin(dir + Math.PI / 2) * thickness;

                // Generate quad vertices (two triangles) for the "thick line"
                vertices.push(
                    x - perpX, y - perpY,
                    newX - perpX, newY - perpY,
                    x + perpX, y + perpY,
                    x + perpX, y + perpY,
                    newX - perpX, newY - perpY,
                    newX + perpX, newY + perpY
                );

                // Update distance attributes for each vertex of the quad
                for (let i = 0; i < 6; i++) {
                    distanceAttributes.push(distance);
                }

                distance += stepSize; // Increment distance for color variation
                x = newX;
                y = newY;
                break;
            case '+':
                dir -= rad(angle); // Turn right by 'angle' degrees
                break;
            case '-':
                dir += rad(angle); // Turn left by 'angle' degrees
                break;
            case '[':
                stack.push({x, y, dir, distance}); // Save state
                break;
            case ']':
                { // Pop state
                    let popped = stack.pop();
                    x = popped.x;
                    y = popped.y;
                    dir = popped.dir;
                    distance = popped.distance; // Restore distance for color continuity
                }
                break;
            // Implement other cases if needed
        }
    });

    // Bind and set up vertex buffer
    const vertexBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);

    // Bind and set up distance buffer
    const distanceBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, distanceBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(distanceAttributes), gl.STATIC_DRAW);

    // Shader attribute locations
    const vertexPosition = gl.getAttribLocation(shaderProgram, 'aVertexPosition');
    gl.enableVertexAttribArray(vertexPosition);
    gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
    gl.vertexAttribPointer(vertexPosition, 2, gl.FLOAT, false, 0, 0);

    const distanceAttribLocation = gl.getAttribLocation(shaderProgram, 'aDistance');
    gl.enableVertexAttribArray(distanceAttribLocation);
    gl.bindBuffer(gl.ARRAY_BUFFER, distanceBuffer);
    gl.vertexAttribPointer(distanceAttribLocation, 1, gl.FLOAT, false, 0, 0);

    // Draw
    gl.useProgram(shaderProgram);
    gl.drawArrays(gl.TRIANGLES, 0, vertices.length / 2); // Draw the triangles
}



function generateLSystem(rules, axiom, depth) {
    let result = axiom;
    for (let i = 0; i < depth; i++) {
        let newResult = '';
        for (const char of result) {
            newResult += rules[char] || char;
        }
        result = newResult;
    }
    return result;
}


/* Mobile Support Functions */

/* Mobile Support */
  function setupSensors() {
        // Check for DeviceOrientationEvent support and request permission on iOS 13+
        if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
            DeviceOrientationEvent.requestPermission()
                .then(response => {
                    if (response === 'granted') {
                        window.addEventListener('deviceorientation', handleOrientation, false);
                    } else {
                        console.error('Device Orientation permission not granted.');
                        // Implement fallback or inform the user as needed
                    }
                })
                .catch(console.error);
        } else {
            // Directly add event listeners for devices not requiring permission (including Android)
            window.addEventListener('deviceorientation', handleOrientation, false);
        }

        // Add devicemotion listener for all devices
        window.addEventListener('devicemotion', handleMotion, false);
}

function handleOrientation(event) {
    const beta = event.beta; // Left / Right tilt.
    let normalizedAngle = beta + 90;
    document.getElementById('angle').value = normalizedAngle.toFixed(2);
}

function handleMotion(event) {
    // Placeholder for motion handling logic
    console.log(event);
}


function isMobileDevice() {
  return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
}

/* Adjust mobile controls */
function adjustLayoutForMobile() {
  if (isMobileDevice()) {
      // Hide controls panel
      document.getElementById('controls').style.display = 'none';

      // Make canvas full screen
      const canvas = document.getElementById('glcanvas');
      canvas.style.width = '100%';
      canvas.style.height = '100vh'; // Use 100% of the viewport height
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
  }
}

// Global variables for angle and mouse position
let angle = 25; // Default angle
let mouseX = 0; // Mouse X position



function main() {
    adjustLayoutForMobile(); // Adjust layout based on the device type
    const canvas = document.getElementById('glcanvas');
    // Set canvas dimensions to 70% of window width and 100% of window height
    canvas.width = window.innerWidth * (isMobileDevice() ? 1 : 0.7); // Adjust size based on device type
    canvas.height = window.innerHeight;
    var drag = false;
    var dragStart;
    var dragEnd;


    // Ensure the CSS styling matches (optional, for consistency)
    canvas.style.width = canvas.width + 'px';
    canvas.style.height = canvas.height + 'px';

    const {gl, shaderProgram} = initWebGL(canvas);
    if (!gl) {
        return;
    }
    gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);

    /* Motion and realtime event listeners */
    setupSensors();


    /* Desktop Support */

    // Setup mouse move event listener to update the angle based on mouse position
    canvas.addEventListener('mousedown', (event) => {
        const rect = canvas.getBoundingClientRect();
        mouseX = event.clientX - rect.left; // Update global mouseX
        const canvasWidth = canvas.clientWidth;
        angle = (mouseX / canvasWidth) * 360; // Map mouse X to a 0-90 degree angle
        document.getElementById('angle').value = angle;
        if(drag === false) {
            drag = true;
        } else { drag = false; }

    });

    // Mobile sup
    canvas.addEventListener('mousemove', (event) => {
      if (drag) {
        const rect = canvas.getBoundingClientRect();
        mouseX = event.clientX - rect.left; // Update global mouseX
        const canvasWidth = canvas.clientWidth;
        angle = (mouseX / canvasWidth) * 360; // Map mouse X to a 0-90 degree angle
        document.getElementById('angle').value = angle;
      }
    });

    // L-system setup
    const rules = {"F": document.getElementById('rule').value};
    const axiom = "F";
    const recursionDepth = 5; // Adjust as needed

    document.getElementById('update').addEventListener('click', () => {
      const axiom = document.getElementById('axiom').value;
      const ruleInput = document.getElementById('rule').value;
      const depth = parseInt(document.getElementById('depth').value, 10);
      const angle = parseFloat(document.getElementById('angle').value);

      // Assuming your rule input format is "F=FF+[+F-F-F]-[-F+F+F]"
      // Convert it into a rules object
      const rules = ruleInput.split(';').reduce((acc, cur) => {
          const parts = cur.split('=');
          acc[parts[0]] = parts[1];
          return acc;
      }, {});

      // Update global variables or directly use these in your draw function
      //drawScene(axiom, rules, depth, angle); // Modify drawScene to accept these parameters
      const instructions = generateLSystem(rules, axiom, recursionDepth);
      drawLSystem(gl, shaderProgram, instructions, angle);
    });

    function animate() {
        requestAnimationFrame(animate); // Continue the animation loop
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT); // Clear the canvas

        const axiom = document.getElementById('axiom').value;
        const ruleStr = document.getElementById('rule').value;
        const depth = parseInt(document.getElementById('depth').value, 10);
        const angle = parseFloat(document.getElementById('angle').value);
        // Generate the L-system string with the current angle
        const instructions = generateLSystem(rules, axiom, recursionDepth);
        // Draw the L-system
        drawLSystem(gl, shaderProgram, instructions, angle);
    }

    animate(); // Start the animation loop
}

window.onload = main;


window.addEventListener('resize', () => {
  location.reload();
  /*
    const canvas = document.getElementById('glcanvas');
    canvas.width = window.innerWidth * 0.7;
    canvas.height = window.innerHeight;

    // Ensure the CSS styling matches (optional, for consistency)
    canvas.style.width = canvas.width + 'px';
    canvas.style.height = canvas.height + 'px';
    gl.viewport(0, 0, canvas.width, canvas.height);

    */
    // You might need to call a function to redraw your scene here
});

</script>
</body>
</html>
